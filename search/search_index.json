{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Lacking is a game engine, or rather framework, written in Go. Unlike other engines that have an Editor UI through which a game is developed in a scripting language, with lacking one makes use of Go's lightning fast compilation times to develop in Go directly with their faviourite IDE and tools.</p> <p>What lacking provides is mechanisms to parse images and 3D model files, to load and render them, and apply physics and another effects on top. All of this is done through DSL or API calls.</p> <p>While there is something like an Editor, its purpose is currently for previewing a scene only.</p> <p>WARNING The lacking repository is a solo hobby project of mine and is still in the prototyping phase. I am iterating fast and making breaking changes. Use at your discretion.</p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Check the Getting Started page on how to set up your own Hello World project.</li> <li>Check the Examples page on games and apps that have been implemented using Lacking.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Following are some example games and apps made with Lacking.</p>"},{"location":"examples/#rally-mka","title":"Rally MKA","text":"<p>Drive around in a car with no particular purpose except to zone out. Best played with keyboard or mouse. The gamepad option is hard.</p> <p></p> <p>This game was the initial reason for the lacking game engine.</p>"},{"location":"examples/#ai-suppression","title":"AI Suppression","text":"<p>A Game Jam entry. Use the keyboard to defend your ship from alien airships. Users of vim will have an easy time here.</p> <p></p> <p>A solo 48h Sofia Game Jam (2023) entry.</p>"},{"location":"examples/#dem-cows","title":"Dem Cows","text":"<p>Fly around in a plane and use a hanging club to pop cow balloons. As it uses semi-realistic physics it is best played with a gamepad and care should be taken regarding stall and speed. There wasn't enough time to balance this game. Winning it with keyboard is nearly impossible.</p> <p></p> <p>A duo 48h Hardcore Game Jam (2024) entry.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The easiest way to set up a new project is to use the <code>template</code> package. Beforehand, make sure you have the necessary prerequisites.</p> <ul> <li> <p>Ensure the Go glfw bindings run on your platform.</p> </li> <li> <p>Ensure you have the gonew tool.</p> <p><code>go install golang.org/x/tools/cmd/gonew@latest</code></p> </li> <li> <p>Ensure you have the task tool.</p> <p><code>go install github.com/go-task/task/v3/cmd/task@latest</code></p> </li> </ul> <p>Afterwards, you can use the following steps:</p> <ol> <li> <p>Create new project using the Lacking template.</p> <p><code>gonew github.com/mokiat/lacking-template@latest example.com/your/namespace projectdir</code></p> <p><code>cd projectdir</code></p> </li> <li> <p>Build and package the assets.</p> <p><code>task pack</code></p> </li> <li> <p>Run the project.</p> <p><code>task run</code></p> </li> </ol> <p>You would only need to run <code>task pack</code> initially and whenever the source resources (images, models) or the pipeline that transforms them have been changed.</p> <p>You can check for available task commands as follows:</p> <pre><code>task --list-all\n</code></pre>"},{"location":"development/math/derivatives/","title":"Derivatives","text":"<p>The following is a table of first order derivatives.</p> Description Derivative Result Constant \\(c'\\) \\(0\\) Variable \\(x'\\) \\(1\\) Scaled variable \\((cx)'\\) \\(cx'\\) Sum \\((x+y)'\\) \\(x' + y'\\) Product \\((xy)'\\) \\(xy'+x'y\\) Quot \\(\\frac{x}{y}\\) \\(\\frac{x.y'+x'.y}{y^2}\\) Reciprocal \\(\\frac{1}{x}\\) \\(\\frac{-x'}{x^2}\\) Power \\((x^y)'\\) \\(yx^{y-1}\\) Square root \\(\\sqrt{x}'\\) \\(\\frac{1}{2\\sqrt{x}}\\) Chained rule \\(\\frac{\\partial f(g(x))}{\\partial x}\\) $\\frac{\\partial f(g(x))}{\\partial g(x)} \\frac{\\partial g(x)}{\\partial x} $ Multivariable rule \\(\\frac{\\partial f(u(x), v(x))}{\\partial x}\\) \\(\\frac{\\partial f(u(x), v(x))}{\\partial u(x)}\\frac{\\partial f(u(x), v(x))}{\\partial u(x)} + \\frac{\\partial f(u(x), v(x))}{\\partial x}\\) Vector square length \\((\\vec{v}.\\vec{v})'\\) \\(2\\vec{v}\\vec{v}'\\) Vector length \\(\\|\\vec{v}\\|'\\) \\(\\hat{v}\\vec{v}'\\)"},{"location":"development/math/vectors/","title":"Vectors","text":"<p>This page presents equations for working with vectors.</p>"},{"location":"development/math/vectors/#length-preservation","title":"Length preservation","text":"\\[ |c\\vec{a}| = c|\\vec{a}| \\]"},{"location":"development/math/vectors/#dot-product","title":"Dot Product","text":"\\[ \\vec{a} \\cdot \\vec{b} = |a||b|\\cos{\\alpha} \\] <p>The dot product is very useful in determining if two vectors are perpendicular or whether they point in the same direction. A value of \\(0\\) indicates that they are perpendicular. A positive value indicates that they point in the same half-space direction. A negataive value indicates that they point in opposite half-space directions.</p> <p>Furthermore, if one of the vectors is unit (has length of one), it returns the length of the other vector's component that is along the first vector's direction. This can be used to measure the distance of a point to a plane if we have the normal of the plane and an arbitrary point on it.</p>"},{"location":"development/math/vectors/#cross-product","title":"Cross Product","text":"\\[ \\vec{a} \\times \\vec{b} = |\\vec{a}||\\vec{b}|\\sin(\\alpha)\\vec{n} \\] <p>The cross product returns a new vector that is perpendicular to both of the initial vectors and has a length equal to the surface area that is bounded by the initial vectors. If the initial vectors are collinear, the resulting vector is the zero vector.</p> <p>This is very useful in physics equations where the resulting concept is perpendicular to the two initial vectors (e.g. the torque vector is perpendicular to the force and the radius).</p> <p>The order of the two vectors matters and flipping the order results in the inverse output vector.</p> \\[ \\vec{a} \\times \\vec{b} = - \\vec{b} \\times \\vec{a} \\] <p>The cross product is distributable over addition.</p> \\[ \\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c} \\]"},{"location":"development/math/vectors/#triple-product","title":"Triple Product","text":"\\[ \\vec{a} \\cdot (\\vec{b} \\times \\vec{c}) = \\vec{b} \\cdot (\\vec{c} \\times \\vec{a}) = \\vec{c} \\cdot (\\vec{a} \\times \\vec{b}) \\] <p>This gives the signed volume of the parallelepiped formed by the three vectors.</p>"},{"location":"development/math/vectors/#matrix-vector-multiplication","title":"Matrix - Vector multiplication","text":"<p>The standard formula for matrix to vector multiplication is as follows:</p> \\[ \\begin{bmatrix} m_1 &amp; m_2 &amp; m_3 \\\\ m_4 &amp; m_5 &amp; m_6 \\\\ m_7 &amp; m_8 &amp; m_9 \\\\ \\end{bmatrix} \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} m_1a_1+m_2a_2+m_3a_3 \\\\ m_4a_1+m_5a_2+m_6a_3 \\\\ m_7a_1+m_8a_2+m_9a_3 \\\\ \\end{bmatrix} \\] <p>This can be expressed in terms of vector dot products:</p> \\[ \\begin{bmatrix} m_1 &amp; m_2 &amp; m_3 \\\\ m_4 &amp; m_5 &amp; m_6 \\\\ m_7 &amp; m_8 &amp; m_9 \\\\ \\end{bmatrix} \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\vec{row_1} \\\\ \\vec{row_2} \\\\ \\vec{row_3} \\\\ \\end{bmatrix} \\vec{a} = \\begin{bmatrix} \\vec{row_1} \\cdot \\vec{a} \\\\ \\vec{row_2} \\cdot \\vec{a} \\\\ \\vec{row_3} \\cdot \\vec{a} \\\\ \\end{bmatrix} \\] <p>Or it can also be expressed in terms of scaled vector sums:</p> \\[ \\begin{bmatrix} m_1 &amp; m_2 &amp; m_3 \\\\ m_4 &amp; m_5 &amp; m_6 \\\\ m_7 &amp; m_8 &amp; m_9 \\\\ \\end{bmatrix} \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} m_1 \\\\ m_4 \\\\ m_7 \\\\ \\end{bmatrix} a_1 + \\begin{bmatrix} m_2 \\\\ m_5 \\\\ m_8 \\\\ \\end{bmatrix} a_2 + \\begin{bmatrix} m_3 \\\\ m_6 \\\\ m_9 \\\\ \\end{bmatrix} a_3 = \\vec{col_1}a_1 + \\vec{col_2}a_2 + \\vec{col_3}a_3 \\]"},{"location":"development/physics/","title":"Physics","text":"<p>The Lacking framework features an impulse-based physics engine. Impulse-based physics engines use velocity corrections to adjust the state of objects and to correct their trajectories according to physical constraints. In addition, the Lacking physics engine features a nudge system that operates directly on positions.</p>"},{"location":"development/physics/#integration","title":"Integration","text":"<p>Integration is one of the fundamental concepts of physics engines. We need to figure out how to move an object based on the forces that act on it and the current velocity (both directional or rotational) it has.</p> <p>For simple scenarios, like constant linear acceleration, this has often been done through equations like the following:</p> \\[ \\Delta p = v_0 \\Delta t + \\frac{1}{2}a{\\Delta t}^2 \\] <p>While this equation works, it assumes that a single force is applied on the object and the acceleration does not change throughout \\(\\Delta t\\). In reality, there can be multiple forces acting on an object that vary depending on the object's position or rotation. For some of those it might be easy to figure out the equation but for others (e.g. The Three-Body Problem) there is no closed-form solution.</p> <p>In such cases, we use a simplified sequence of operations that do not produce an exact solution but compensate with flexibility and performance. After it is applied, corrections are performed to ensure that a physics constraint is not violated (e.g. an object should not go through another object).</p> <p>There are a number of famous integration methods out there. Lacking uses the semi-implicit Euler integration method.</p> \\[ v_1 = v_0 + a \\Delta t \\] \\[ s_1 = s_0 + v_1 \\Delta t \\] <p>More broadly, it performs the following sequence of steps.</p> <ol> <li>Applies forces to all dynamic objects.</li> <li>Derives the new velocities of all dynamic objects based on the accumulated accelerations.</li> <li>Applies correction impulses to all dynamic objects that have constraints on them.</li> <li>Derives the new positions of all dynamic objects based on the evaluated velocitiess</li> <li>Applies correction nudges to all dynamic objects that have constraints on them.</li> <li>Detects collisions and creates temporary collision constraints.</li> </ol> <p>For more information on integration, make sure to check the References page.</p>"},{"location":"development/physics/#impulses","title":"Impulses","text":"<p>Outside the standard integration, when adjustments are needed to an object's velocity, the engine uses impulses.</p> <p>Impulses are like forces, except that they deal with the velocity instead of the acceleration.</p> \\[ P = \\Delta{t}F = vm \\] <p>And just as forces applied at an offset to an object induce both a change in linear and angular accelerations, impulses induce both a change in linear and angular velocities.</p> \\[ \\Delta{\\vec{v}} = m^{-1} \\vec{P} \\] \\[ \\Delta{\\vec{w}} = I^{-1}(\\vec{r} \\times \\vec{P}) \\]"},{"location":"development/physics/#constraints","title":"Constraints","text":"<p>Constraints are a mechanism to enforce a physics rule or restriction on an object. Examples include having an object always point towards a point in space, preventing an object from falling through the ground, restricting the motion of an object to a single axis, etc.</p> <p>The way constraints are expressed mathematically is through equations that equal zero when the constraint is satisfied.</p> \\[ C = 0 \\] <p>For example, the following constraint requires that an object has a position \\(p\\) a specific distance \\(l\\) away from a point \\(p_0\\).</p> \\[ C_p(p) = |\\vec{p} - \\vec{p_0}| - l \\] <p>The above equation is equal to \\(0\\) only when the object is \\(l\\) distance away from \\(p_0\\).</p> <p>As mentioned before, an impulse engine uses velocity adjustments (impulses) to enforce constraints. As such, we require constraint functions that take the object's velocity as an argument. We achieve this by using the positional constraint and differentiation over time. For the above positional constraint, we get the following velocity constraint.</p> \\[ C_v(v) = C_p' = \\frac{\\vec{p} - \\vec{p_0}}{|\\vec{p} - \\vec{p_0}|} \\cdot \\vec{v} \\] <p>Our next step is to get the gradient of the constraint. This allows us to use gradient descent to make the optimal velocity adjustments. We do this through differentiation over the velocity.</p> \\[ \\nabla{C_v}(v) = \\frac{\\vec{p} - \\vec{p_0}}{|\\vec{p} - \\vec{p_0}|} \\] <p>Note: In some literature the constraint gradient is also called the Jacobian. Since the \\(C_v\\) function maps from \\(R^n\\) to \\(R^1\\), the Jacobian and gradient are the same thing, except that the former is represented by a single-row matrix and the latter is represented by a vactor. This also means that using a Jacobian, one has to use matrix multiplication and using a gradient one has to use the vector dot product respectively. Since it is easier to write, we will use \\(J\\) to represent the above gradient. Furthermore, unless otherwise specified, \\(J\\) indicates \\(J(v)\\) (the Jacobian at velocity \\(v\\)).</p> <p>Once we have the Jacobian, we can use the direction it implies to apply an impulse on the object.</p> \\[ \\vec{P} = J^T \\lambda \\] <p>Note: we transpose the jacobian to convert it from a \\(1 \\times 3\\) (when working in 3D) matrix, to a 3D vector.</p> <p>While the Jacobian \\(J\\) (or rather the inverse) determines the direction, the \\(\\lambda\\) scalar determines the strength of the impulse. Where \\(\\lambda\\) is calculated as follows.</p> \\[ \\lambda = - \\frac{J\\vec{v_0}}{JM^{-1}J^T} \\] <p>Here \\(\\vec{v_0}\\) is the current velocity of the object and \\(M^{-1}\\) is the inverse mass matrix, though \\(\\frac{1}{m}\\) works just as well in the general case. It is also the case that \\(JM^{-1}J^T\\) produces the inverse effective mass.</p> <p>This brings the equation down to:</p> \\[ \\vec{P} = - J^T \\frac{J\\vec{v_0}}{JM^{-1}J^T} \\] <p>In practice, we often have an offset impulse, in which case we need to take the moment of inertia and the current angular velocity into account. The equation is pretty much the same, except that the velocity vector now includes the angular components as well and the mass matrix includes the moment of inertia.</p> \\[ \\vec{v_0} = \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ w_x \\\\ w_y \\\\ w_z \\\\ \\end{bmatrix} \\] \\[ M = \\begin{bmatrix} m &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; m &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; m &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; I_{xx} &amp; I_{xy} &amp; I_{xz} \\\\ 0 &amp; 0 &amp; 0 &amp; I_{yx} &amp; I_{yy} &amp; I_{yz} \\\\ 0 &amp; 0 &amp; 0 &amp; I_{zx} &amp; I_{zy} &amp; I_{zz} \\\\ \\end{bmatrix} \\] <p>Note: Don't forget that the inverse of the matrix \\(M\\) is used in the equations above.</p> <p>More information on how the above equation was derived can be found on the Impulse Derivation page.</p>"},{"location":"development/physics/#solver","title":"Solver","text":"<p>In general, there are two main ways to solve constraints.</p> <p>The first one is to solve the mathematic equations for all constraints in parallel and then apply a single impulse per object that produces the desired output. This approach is difficult in that the complexity rises drastically with each new constraint and there can be situations where an exact solution does not even exist (e.g. two constraints that require the object be positioned in two different spots).</p> <p>The second one is to solve constraints for maximum two bodies at a time. Each constraint is solved an applied in turn. The whole process is repeated a number of times until the system hopefully reaches a \"stable\" state. In practice this is cheaper to run and produces good results. It is very similar to how Neural Networks are trained.</p> <p>For more information on constraint solvers, make sure to check the References page.</p>"},{"location":"development/physics/references/","title":"References","text":"<p>The following articles and videos are a good place to start.</p>"},{"location":"development/physics/references/#moment-of-intertia","title":"Moment of Intertia","text":"<ul> <li>What is a tensor</li> <li>Inertia Tensor</li> <li>The Inertia Tensor for a Cube</li> <li>Why is inertia tensor called a tensor as opposed to matrix</li> <li>Relation between torque and moment of inertia</li> </ul>"},{"location":"development/physics/references/#jacobian","title":"Jacobian","text":"<ul> <li>Jacobian prerequisite knowledge</li> <li>Local linearity for a multivariable function</li> <li>The Jacobian matrix</li> <li>Computing a Jacobian matrix</li> <li>The Jacobian Determinant</li> <li>Gradient</li> <li>Gradient and graphs</li> <li>Directional derivative</li> <li>Directional derivatives and slope</li> <li>Why the gradient is the direction of steepest ascent</li> <li>Gradient descent, how neural networks learn | Chapter 2</li> </ul>"},{"location":"development/physics/references/#integration","title":"Integration","text":"<ul> <li>Integration Basics</li> <li>Fix Your Timestep!</li> <li>Physics for Game Programmers: Understanding Constraints</li> </ul>"},{"location":"development/physics/references/#constraint-optimization","title":"Constraint Optimization","text":"<ul> <li>Constrained optimization introduction</li> <li>Lagrange multipliers, using tangency to solve constrained optimization</li> <li>Finishing the intro lagrange multiplier example</li> <li>Lagrange multiplier example, part 1</li> <li>Lagrange multiplier example, part 2</li> <li>The Lagrangian</li> <li>Meaning of Lagrange multiplier</li> <li>Proof for the meaning of Lagrange multipliers</li> </ul>"},{"location":"development/physics/references/#constraint-solver","title":"Constraint Solver","text":"<ul> <li>Physics for Game Programmers: Understanding Constraints</li> <li>Game Physics: Resolution - Constraints &amp; Sequential Impulse</li> <li>Equality Constraints</li> <li>Position Correction</li> <li>Soft constraint derivation</li> </ul>"},{"location":"development/physics/references/#collision-detection","title":"Collision Detection","text":"<ul> <li>SAT (Separating Axis Theorem)</li> <li>Collision Detection Using the Separating Axis Theorem</li> <li>Gilbert\u2013Johnson\u2013Keerthi distance algorithm</li> <li>A Strange But Elegant Approach to a Surprisingly Hard Problem (GJK Algorithm)</li> <li>How does a collision engine work?</li> </ul>"},{"location":"development/physics/derivations/effective-mass-derivation/","title":"Effective Mass Derivation","text":"<p>Following is a derivation of the <code>effective mass</code> as discussed in the physics theory section.</p> <p>Let us consider an object that is experiencing both a linear acceleration \\(a\\) and an angular acceleration \\(\\alpha\\) but has one of its sides attached to a stationary anchor point \\(p\\). We would like to know what force the anchor point exerts on the object (and vice versa). Following is a depiction of the scenario.</p> <p></p> <p>We should consider the point \\(p\\) on the object that is attached to the anchor. Since the anchor does not budge, we expect that point \\(p\\) has to be stationary as well. Let's look at what accelerations the point \\(p\\) experiences.</p> <p>The first acceleration it experiences is the one from the object's acceleration and angular acceleration.</p> \\[ a_{object} = a + \\alpha r \\] <p>The equation above is the one we already looked at in the tangental acceleration section.</p> <p>The second acceleration it experiences is the one from the anchor, which is trying to resist the point's motion.</p> \\[ a_{anchor} = -\\frac{F_{anchor}}{m} - \\frac{F_{anchor}r^2}{I} \\] <p>Note: The sign is negative, as the anchor acceleration acts in the opposite direction.</p> <p>The second equation might be a bit more complicated. Let's look at how we arrived at the two terms. The first one represents the linear acceleration that the whole object would experience because of \\(F_{anchor}\\) and the second one is the angular acceleration.</p> <p>Recall from offset force that a force applied to an object induces both a force at the center of mass and a torque.</p> <p>The linear acceleration is dervied as follows.</p> \\[ F_{cm} = -F_{anchor} \\] \\[ \\Downarrow \\] \\[ a_{cm} = \\frac{F_{cm}}{m} = -\\frac{F_{anchor}}{m} \\] <p>And the angular acceleration is derived as follows.</p> \\[ \\tau_{cm} = -F_{anchor} r \\] \\[ \\Downarrow \\] \\[ \\frac{\\tau_{cm}}{I} = -\\frac{F_{anchor} r}{I} \\] \\[ \\Downarrow \\] \\[ \\alpha = -\\frac{F_{anchor} r}{I} \\] \\[ \\Downarrow \\] \\[ \\alpha r = -\\frac{F_{anchor} r r}{I} = -\\frac{F_{anchor} r^2}{I} \\] \\[ \\Downarrow \\] \\[ a_{tangent} = -\\frac{F_{anchor} r r}{I} = -\\frac{F_{anchor} r^2}{I} \\] <p>Combining both the linear and angular accelerations, we get the following point acceleration due to the anchor force.</p> \\[ a_{anchor} = a_{cm} + a_{tangent} = - \\frac{F_{anchor}}{m} - \\frac{F_{anchor}r^2}{I} \\] <p>If the point \\(p\\) is to be stationary, we want the acceleration induced by the object to be negated by the acceleration induced by the anchor force.</p> \\[ - a_{anchor} = a_{object} \\] \\[ \\Downarrow \\] \\[ \\frac{F_{anchor}}{m} + \\frac{F_{anchor}r^2}{I} = a + \\alpha r \\] \\[ \\Downarrow \\] \\[ F_{anchor} (\\frac{1}{m} + \\frac{r^2}{I}) = (a + \\alpha r) \\] <p>Which results in the following equation for the force being felt by the anchor point.</p> \\[ F_{anchor} = (a + \\alpha r) \\frac{1}{\\frac{1}{m} + \\frac{r^2}{I}} \\] <p>If we consider the above to describe the Force as being induced by a single point, we could split it into the following segments.</p> \\[ a_{eff} = (a + \\alpha r) \\] \\[ m_{eff} = \\frac{1}{\\frac{1}{m} + \\frac{r^2}{I}} \\] <p>The way you can think of the effective mass is that it represents the inertial mass of the object at that particular offset point (i.e. how much would it resist motion if a force were applied at that particular position).</p> <p>Of course, this is mostly a thought experiment but the effective mass can be useful, since it does simplify a lot of problem scenarios. Furthermore, it highlights that the anchor point does not experience the full weight of an object.</p>"},{"location":"development/physics/derivations/effective-mass-derivation/#effective-mass-in-practice","title":"Effective Mass in Practice","text":"<p>The equation we derived above makes some assumptions. It looks at an idealized scenario where the force is perpendicular to the radius, meaning it applies maximum torque. In reality, the forces we deal with can have arbitrary directions. Furthermore, we looked at a 2D scenario, whereas a 3D one is a bit more intricate due to the moment of inertia.</p> <p>If we rework the above equation for 3D, we get to the following equation.</p> \\[ m_{eff} = \\frac{1}{m^{-1} + I^{-1}(\\vec{r} \\times \\hat{n})^2} \\] <p>Note that while \\(m^{-1}\\) is just \\(\\frac{1}{m}\\), the \\(I^{-1}\\) term is actually the inverse matrix of the inertia tensor. Furthermore, despite \\((\\vec{r} \\times \\hat{n})\\) being squared for brevity, it is not possible to do that multiplication first, since these are two column vectors. Instead, that term needs to be multiplied two times to the inverse inertia tensor matrix, which will yield a scalar value.</p> <p>Note also, that \\((\\vec{r} \\times \\hat{n})\\) produces a vector in the direction of rotation, which is the correct way to multiply by the inertia tensor.</p> <p>Lastly, in practice, most algorithms in the physics engine actually need the inverse effective mass \\(m_{eff}^{-1}\\), which is actually easier to write.</p> \\[ m_{eff}^{-1} = m^{-1} + I^{-1}(\\vec{r} \\times \\hat{n})^2 \\] <p>In fact, having it written in this form will make some other equations to follow nicer as well.</p>"},{"location":"development/physics/derivations/effective-mass-derivation/#reduced-effective-mass","title":"Reduced Effective Mass","text":"<p>When dealing with two objects that are tied together or are experiencing a collision, the correction impulses we need to apply to the objects (actually the same impulse with two opposite directions) need to take the two masses into consideration.</p> <p>In such cases the combined (reduced mass) can be calculated as follows.</p> \\[ m_{red} = \\frac{1}{m_{1eff}^{-1} + m_{2eff}^{-1}} \\] <p>As with the individual effective masses, here too we prefer using the inverse of the reduced mass, which has a more simplified form, as follows.</p> \\[ m_{red}^{-1} = m_{1eff}^{-1} + m_{2eff}^{-1} \\] <p>or</p> \\[ \\frac{1}{m_{red}} = \\frac{1}{m_{1eff}} + \\frac{1}{m_{2eff}} \\] <p>The derivation is based on the equations for momentum and preservation of momentum on collision.</p>"},{"location":"development/physics/derivations/effective-mass-derivation/#inelastic-collision","title":"Inelastic collision","text":"<p>In the case where we have the two objects tied together (e.g. a hinged rod constraint), we can think of them experiencing constant inelastic collisions.</p> \\[ m_1 u_1 + m_2 u_2 = (m_1 + m_2) v \\] <p>From the point of view of \\(v\\) this equation can also be expressed as:</p> \\[ v = \\frac{m_1 u_1 + m_2 u_2}{m_1 + m_2} \\] <p>Here \\(m_1\\) and \\(m_2\\) are the effective masses of the two objects, \\(u_1\\) and \\(u_2\\) are their initial (pre-collision) velocities respectively, and \\(v\\) is the final velocity (post-collision) that they will both share.</p> <p>The change in velocity for the first object can be expressed as follows.</p> \\[ \\Delta v_1 = v - u_1  \\] <p>The impulse that will provide such a change in velocity has the following equation.</p> \\[ P_1 = \\Delta v m_1 = (v - u_1) m_1 \\] <p>Plugging in the equation for \\(v\\) from above, we get the following equation.</p> \\[ P_1 = (\\frac{m_1 u_1 + m_2 u_2}{m_1 + m_2} - u_1) m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = (\\frac{m_1 u_1 + m_2 u_2 - m_1 u_1 - m_2 u_1}{m_1 + m_2}) m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = (\\frac{m_2 u_2 - m_2 u_1}{m_1 + m_2}) m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = (u_2 - u_1) \\frac{m_1 m_2}{m_1 + m_2} \\] <p>Lastly, we can do the following transformation on the mass-related part of the equation.</p> \\[ \\frac{m_1 m_2}{m_1 + m_2} = \\frac{1}{\\frac{m_1 + m_2}{m_1 m_2}} =  \\frac{1}{\\frac{m_1}{m_1 m_2} + \\frac{m_2}{m_1 m_2}} = \\frac{1}{\\frac{1}{m_2} + \\frac{1}{m_1}} \\] <p>Hence, we have the following.</p> \\[ m_{red} = \\frac{1}{\\frac{1}{m_2} + \\frac{1}{m_1}} \\] <p>And with one last transformation, we have the desired equation.</p> \\[ \\frac{1}{m_{red}} = \\frac{1}{m_2} + \\frac{1}{m_1} \\]"},{"location":"development/physics/derivations/effective-mass-derivation/#elastic-collision","title":"Elastic collision","text":"<p>The equation for elastic collision is as follows.</p> \\[ v_1 = \\frac{(m_1 - m_2)}{(m_1 + m_2)} u_1 + \\frac{2 m_2}{(m_1 + m_2)} u_2 \\] <p>We follow the same approach as with the inelastic collision by expressing the change of velocity of one of the objects through an impulse.</p> \\[ P_1 = \\left[ \\frac{(m_1 - m_2)}{(m_1 + m_2)} u_1 + \\frac{2 m_2}{(m_1 + m_2)} u_2 - u_1 \\right] m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = \\left[ \\frac{(m_1 u_1 - m_2 u_1)}{(m_1 + m_2)} + \\frac{2 m_2 u_2}{(m_1 + m_2)} - \\frac{m_1 u_1 + m_2 u_1}{(m_1 + m_2)} \\right] m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = \\left[ \\frac{m_1 u_1 - m_2 u_1 + 2 m_2 u_2 - m_1 u_1 - m_2 u_1}{m_1 + m_2} \\right] m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = \\left[ \\frac{2 m_2 u_2 - 2 m_2 u_1}{m_1 + m_2} \\right] m_1 \\] \\[ \\Downarrow \\] \\[ P_1 = 2(u_2 - u_1) \\frac{m_1 m_2}{m_1 + m_2} \\] <p>Once again, the mass-related part of the equation is the same, hence proving our derivation of the reduced mass.</p> <p>Note that the constant \\(2\\) in the equation is not part of the mass. It has to do with the type of collision and is related to the coefficient of restitution.</p> <p>The actual equation, and in fact a more general equation for both types of collisions, is as follows.</p> \\[ P_1 = (1 + e) (u_2 - u_1) \\frac{m_1 m_2}{m_1 + m_2} \\] <p>The \\(e\\) term is a scalar ranging from \\(0\\) to \\(1\\) and represents how elastic a collision is.</p> <p>One last thing to mention is that the impulse acting on the other object is the same, except that it has the opposite direction - we have \\((u_1 - u_2)\\).</p>"},{"location":"development/physics/derivations/impulse-derivation/","title":"Impulse Derivation","text":"<p>This page dives into a bit more details as to how we get to the impulse equation.</p>"},{"location":"development/physics/derivations/impulse-derivation/#single-body-constraint","title":"Single-body Constraint","text":"<p>Let's consider a point \\(p\\) of an object. The point need not necessarily be the center of mass of the object. Let us also imagine that we have a positional constraint \\(C_p\\) for that point.</p> <p>Following is an example of a constraint that ensures that point \\(p\\) is at distance \\(l\\) from some world coordinate \\(k\\).</p> \\[ C_p(p) = |\\vec{p} - \\vec{k}| - l \\] <p>This can be depicted as follows.</p> <p></p> <p>We get the velocity constraint by differentiating over time.</p> \\[ C_v(v) = C_p' = \\frac{(\\vec{p} - \\vec{k})}{|\\vec{p} - \\vec{k}|} \\cdot p' = \\frac{(\\vec{p} - \\vec{k})}{|\\vec{p} - \\vec{k}|} \\cdot \\vec{v} \\] <p>For simplicity, let us track the position difference between point \\(p\\) and \\(k\\) as \\(\\vec{d}\\). We get the following.</p> \\[ C_v(v) = \\hat{d} \\cdot \\vec{v} \\] <p>The velocity \\(v\\) of point \\(p\\) is actually the combination of the linear and angular velocities of the object, as follows.</p> \\[ \\vec{v} = \\vec{v_o} + \\vec{w_o} \\times \\vec{r} \\] <p>Here \\(\\vec{r}\\) denotes \\((\\vec{p} - \\vec{o})\\), where \\(o\\) is the center of mass of the object.</p> <p>Next we calculate the (single-row) Jacobian matrix \\(J\\) by differentiating over each individual velocity component (including the angular velocity components).</p> \\[ J^T = \\begin{bmatrix} \\hat{d}_x \\\\ \\hat{d}_y \\\\ \\hat{d}_z \\\\ (\\vec{r} \\times \\hat{d})_x \\\\ (\\vec{r} \\times \\hat{d})_y \\\\ (\\vec{r} \\times \\hat{d})_z \\\\ \\end{bmatrix} \\] <p>Note: For the angular velocity components we use the triple product rule, which transforms \\(\\hat{d} \\cdot (\\vec{w_o} \\times \\vec{r})\\) into \\(\\vec{w} \\cdot (\\vec{r} \\times \\hat{d})\\), making it much easier to differentiate.</p> <p>Now that we have the jacobian, we can determine how much the object's linear and angular velocities violate the constraint by multiplying them.</p> \\[ c_{err} = J V_{obj} \\] <p>Note that \\(V_{obj}\\) here represents a vector containing both linear and angular velocity components.</p> <p>What we want to do is to apply an impulse \\(P\\) such that the constraint error of the new velocity is zero. There are a number of impulse vectors that can adjust the object's velocity, and in response the point's velocity, such that the constraint is satisfied.</p> <p></p> <p>Note: The <code>P</code> vectors on the diagram don't represent the actual impulses but rather the outcome on the point's velocity. The actual impulses are applied to the object's center in the form of both linear and angular velocity changes, however, it would be hard to visualize them in a meaningful way on the diagram.</p> <p>We need to pick such a combination of linear and angular velocity changes such that energy is not introduced in the system, though losing some energy is acceptable. We do this by performing a gradient descent using the Jacobian (which is just a transposed gradient).</p> \\[ P = J^T \\lambda \\] <p>Here \\(\\lambda\\) is the impulse strength that we next need to derive. Also, the \\(P\\) vector includes both the linear and angular components (i.e. is 6-dimensional) and the angular velocity components are already scaled by the necessary radius amount and effective mass, same as the linear velocity components.</p> <p>Thus, the change in velocity of the object can be expressed as follows.</p> \\[ \\Delta V = M^{-1} P \\] \\[ \\Downarrow \\] \\[ \\Delta V = M^{-1} J^T \\lambda \\] <p>As mentioned above, we want the new velocity to have zero constraint error.</p> \\[ c_{err} = J V_{new} = 0 \\] <p>Knowing that \\(V_{new} = V + \\Delta V\\), we can express it as follows.</p> \\[ c_{err} = J (V + \\Delta V) = 0 \\] <p>Replacing \\(\\Delta V\\) with the above equation, we get the following expression.</p> \\[ J (V + M^{-1} J^T \\lambda) = 0 \\] \\[ \\Downarrow \\] \\[ J V + J M^{-1} J^T \\lambda = 0 \\] \\[ \\Downarrow \\] \\[ J M^{-1} J^T \\lambda = - J V \\] \\[ \\Downarrow \\] \\[ \\lambda = - \\frac{J V}{J M^{-1} J^T} \\] <p>Once we plug \\(\\lambda\\) into the impulse equation, we get the final form.</p> \\[ P = - J^T \\frac{J V}{J M^{-1} J^T} \\] <p>If we were to substitute the Jacobian arguments with the example ones from above, we will realize that \\(J M^{-1} J^T\\) actually produces \\(m_{eff}^{-1}\\) and \\(JV\\) equals \\(C_v(V)\\), leading to the following.</p> \\[ P = - J^T \\left[ C_v(V) m_{eff} \\right] \\] <p>In reality, however, the above equation is more useful, since we only need to calculate the inverse mass and the jacobian once and we have all that is needed to resolve the constraint.</p>"},{"location":"development/physics/derivations/impulse-derivation/#double-body-constraint","title":"Double-body Constraint","text":"<p>Solving double-body constraints is fairly similar, except that the Jacobian is now 12-dimensional, since it contains the linear and angular components of both objects.</p>"},{"location":"development/physics/derivations/impulse-derivation/#inequality-constraints","title":"Inequality Constraints","text":"<p>Some constraints are applicable only half-way, for example a collision between an object and a surface. We want to apply the constraint only if it is unsatisfied at one end (either positive or negative - up to the reader).</p> \\[ C_p(P) &gt;= 0 \\] \\[ \\Downarrow \\] \\[ C_v(V) &gt;= 0 \\] <p>From an implementation point of view, it is possible to just check it and not apply any impulses if positive. However, there is also the aspect of bounciness. So far, we have been adjusting the velocities in such a way as to remove the excess velocity in a certain direction. With inequality constraints the desired outcome could be that the object bounce back with the same or similar velocity.</p> <p>We can do this by applying up to twice the correction impulse and can control this using the coefficient of restitution.</p> \\[ \\lambda = - (1 + e) \\frac{J V}{J M^{-1} J^T} \\] <p>Here \\(e\\) usually ranges from \\(0\\) to \\(1\\) in value. A value of \\(0\\) indicates an inelastic collision whereas a value of \\(1\\) indicates a fully elastic collision.</p> <p>Specifying a negative value is meaningless and specifying a value bigger than \\(1\\) would introduce energy into the system, which might be desired in some special circumstances (e.g. a jump platform).</p> <p>Side note: It is possible to reuse the same equation for equality constraints as well, one just needs to treat them as inelastic and always specify \\(e = 0\\).</p>"},{"location":"development/physics/theory/effective-mass/","title":"Effective Mass","text":"<p>I was unable to find a correct term for this. The articles refer to it as Effective Mass, though it means a different thing in practice. Regardless, I will stick with the term Effective Mass to keep this consistent with other tutorials out there.</p> <p>The effective mass is represented with the following equation.</p> \\[ m_{eff} = \\frac{1}{m^{-1} + I^{-1}(\\vec{r} \\times \\hat{n})^2} \\] <p>It represents the inertial mass of an object when interacted with at an offset (e.g. an airplane wing-mounted engine pushing on the airplane).</p> <p>In practice we will be using the inverse effective mass which has the following equation.</p> \\[ m_{eff}^{-1} = m^{-1} + I^{-1}(\\vec{r} \\times \\hat{n})^2 \\] <p>Lastly, if dealing with two objects, the inverse of the reduced effective mass of the system can be calculated as follows.</p> \\[ m_{eff}^{-1} = m_1^{-1} + I_1^{-1}(\\vec{r_1} \\times \\hat{n})^2 + m_2^{-1} + I_2^{-1}(\\vec{r_2} \\times \\hat{n})^2 \\] <p>A detailed derivation of the above equation can be found on the Effective Mass Derivation page.</p>"},{"location":"development/physics/theory/equations/","title":"Equations","text":"Equation Vector form Notes \\(F = ma\\) \\(\\vec{F} = M \\vec{a}\\) The force is collinear to the acceleration and is proportional to the mass. \\(p = mv\\) \\(\\vec{p} = M \\vec{v}\\) The momentum is collinear to the velocity and is proportional to the mass. \\(\\tau = I \\alpha\\) \\(\\vec{\\tau} = I \\vec{\\alpha} + \\vec{\\omega} \\times I \\vec{\\omega}\\) The vector form in 3D is the more accurate representation. It takes into account the fact that there can be a torque even without an angular acceleration, just because of the shape of the object. Check Moment of Intertia for more information. The torque might not be collinear with the angular acceleration. \\(\\tau = rF\\) \\(\\vec{\\tau} = \\vec{r} \\times \\vec{F}\\) The cross product handles situations where the radius is not perpendicular to the force. \\(L = I\\omega\\) \\(\\vec{L} = I \\vec{\\omega}\\) The angular momentum need not be collinear with the angular velocity. Check Moment of Intertia for more information. \\(v_t = \\omega r\\) \\(\\vec{v_t} = \\vec{\\omega} \\times \\vec{r}\\) The cross product handles situations where the radius is not perpendicular to the angular velocity. The resulting tangential velocity, when not zero, is perpendicular to the angular velocity. \\(a_t = \\alpha r\\) \\(\\vec{a_t} = \\vec{\\alpha} \\times \\vec{r}\\) The cross product handles situations where the radius is not perpendicular to the angular acceleration. \\(F = \\mu F_n\\) \\(\\vec{F_{max}} = - \\mu \\hat{v_{t}} \\|\\vec{F_n}\\|\\) This returns the maximum friction force. The actual force could be less if it would be sufficient to keep the object from moving. \\(F_d = \\frac{1}{2} \\rho v^2 C_d A\\) \\(\\vec{F_d} = \\frac{1}{2} \\rho C_d A \\|\\vec{v}\\| \\vec{v}\\) The velocity in this equation is the relative velocity of the wind to the object. \\(F_l = \\frac{1}{2} \\rho v^2 C_L A\\) \\(\\vec{F_l} = \\frac{1}{2} \\rho C_L A (\\vec{v} \\cdot \\vec{v}) \\hat{n}\\) The velocity in this equation is the relative velocity of the wind to the object. The \\(\\hat{n}\\) term defines the lift direction of the wing, perpendicular to the wind direction. \\(F_s = k x\\) \\(\\vec{F_s} = -k \\vec{x}\\) This is according to Hooke's law, though not all springs follow that law. The force is in the opposite direction to the displacement."},{"location":"development/physics/theory/moment-of-intertia/","title":"Moment of Intertia","text":"<p>While mass represents the reluctance of an object to change its linear velocity, moment of inertia represents the reluctance of an object to change its angular momentum. However, while having a lot of things in common, mass is much easier to reason about, whereas moment of inertia induces some strange properties on the motion of an object. This is why this page is dedicated to discussing Moment of Inertia.</p> <p>NOTE: I have not studied physics past high school so more of the advanced stuff here is based on internet articles, tutorials, and personal reasoning. Take everything with a grain of salt.</p> <p>The two main equations related to mass are as follows.</p> \\[ \\vec{p} = M \\vec{v} \\] <p>and</p> \\[ \\vec{F} = M \\vec{a} \\] <p>Where the second equation is derived by taking the derivative of the first one over time. In fact, it seems that Newton's second law of motion describes Force as the rate at which the momentum of an object changes with time.</p> <p>For moment of inertia the equations are fairly similar.</p> \\[ \\vec{L} = I \\vec{\\omega} \\] <p>and</p> \\[ \\vec{\\tau} = I \\vec{\\omega} \\] <p>Except that the second equation is actually wrong. While very common in a lot of text books, it works correctly only for 2D scenarios or in 3D scenarios where the rotation occurs over one of the principal axes (more on that later) of the object.</p> <p>The correct equation is actually as follows.</p> \\[ \\vec{\\tau} = I \\vec{\\alpha} + \\vec{\\omega} \\times I \\vec{\\omega} \\] <p>In fact, similarly to the equation for force, this one is also derived by taking the derivative of the angular momentum equation (the first one) over time.</p> <p>A key thing to note here is that unlike the force equation, where the mass is a scalar, in this equation the moment of inertia is actually a 3x3 matrix called a tensor. The reason for this is because the resistence to rotation differs depending on the angle of rotation. What's even more, the angular momentum or the torque (depending on which equation above is used) need not point in the same direction as the angular velocity or angular acceleration.</p> <p>NOTE: This last bit was hard for me to understand or create a mental image of. In the following text I will try to create a mostly intuitive explanation as to why the equation for torque is so complicated.</p>"},{"location":"development/physics/theory/moment-of-intertia/#the-intertia-tensor","title":"The Intertia Tensor","text":"<p>We should first explore the Inertia Tensor \\(I\\). As mentioned, it is a 3x3 matrix that is defined as follows.</p> \\[ I = \\begin{bmatrix} I_{xx} &amp; I_{xy} &amp; I_{xz} \\\\ I_{yx} &amp; I_{yy} &amp; I_{yz} \\\\ I_{zx} &amp; I_{zy} &amp; I_{zz} \\\\ \\end{bmatrix} \\] <p>The components can be calculated as follows:</p> \\[ I_{xx} = \\sum_i{m_i (y_i^2 + z_i^2)} \\] \\[ I_{yy} = \\sum_i{m_i (x_i^2 + z_i^2)} \\] \\[ I_{zz} = \\sum_i{m_i (x_i^2 + y_i^2)} \\] \\[ I_{xy} = I_{yx} = - \\sum_i{m_i x_i y_i} \\] \\[ I_{xz} = I_{zx} = - \\sum_i{m_i x_i z_i} \\] \\[ I_{yz} = I_{zy} = - \\sum_i{m_i y_i z_i} \\] <p>Where \\(m_i\\) represents the mass of an individual particle of the object and \\(x_i\\), \\(y_i\\) and \\(z_i\\) represent the location of the particle relative to the point of rotation.</p> <p>One can use integration to solve the above equations for various shape types.</p> <p>Check the References page for links to resources with more detailed information on how this is derived.</p> <p>So what is the difference between a tensor and a 3x3 matrix. Well, to my understanding, a tensor describes a transformation under a change of coordinates. It can produce a scalar, a vector, or more complicated outputs.</p> <p>In the case of the moment of inertia, an input vector is transformed to an output vector and the transformation is linear, which is a tensor of second order and is described by a symmetric matrix.</p> <p>The components \\(I_{xx}\\), \\(I_{yy}\\), and \\(I_{zz}\\) are called the moments of inertia, whereas the other components, \\(I_{xy}\\), \\(I_{yx}\\), \\(I_{xz}\\), \\(I_{zx}\\), \\(I_{yz}\\), and \\(I_{zy}\\), are called the products of inertia.</p> <p>My understanding is that for any object, if you position the point of rotation to be the center of mass (which would be the common case for a physics engine), you can find three orthogonal axes, such that the products of inertia are zero. In such cases, the axes are called principal axes and rotation over them does not induce any torque (i.e. we can the more simple \\(\\vec{\\tau} = I \\vec{\\alpha}\\) equation). The moment of inertia becomes a diagonal matrix.</p>"},{"location":"development/physics/theory/moment-of-intertia/#the-torque-equation","title":"The torque equation","text":"<p>So now that we know how the moment of inertia is calculated and represented, let's get back to the intimidating torque equation.</p> \\[ \\vec{\\tau} = I \\vec{\\alpha} + \\vec{\\omega} \\times I \\vec{\\omega} \\]"},{"location":"development/physics/theory/moment-of-intertia/#velocity-induced-torque","title":"Velocity-induced torque","text":"<p>Let us consider the second part of the equation.</p> \\[ \\vec{\\omega} \\times I \\vec{\\omega} \\] <p>It tells us that a torque can be induced by the angular velocity alone, even if there is no angular acceleration.</p> <p>NOTE: This torque does not appear if an object is rotated about one of its principal axes.</p> <p>The best way to reason about this is to look at a very simplified and idealized version of a scenario where a torque is induced due to velocity. Let us explore the following setup.</p> <p></p> <p>We have an object comprised of two particles (\\(p_1\\) and \\(p_2\\)), connected by a zero-mass rod (in red). The object is rotating with an angular velocity \\(\\omega\\).</p> <p>Before diving into the moment inertia tensor and the equations from above, let us try to use high-school physics to evaluate what forces will act on the particles and if there is any torque actually induced.</p> <p>If we look at point \\(p_1\\), we can see that it is spinning with tangental velocity magninute of \\(x \\omega\\) (again, using high-school physics/math), which in our case is \\(2 \\omega\\).</p> <p>Since there are no external forces (there is no angular acceleration on the object), the only force that the particle experiences is the one by the rod that is keeping it attached to the object. The opposite (but equal) force is actually the fictitious Centrifugal force.</p> <p>That force is equal to the following.</p> \\[ F_1 = mw^2r = mw^2x = 2mw^2 \\] <p>This force induces a torque on the whole object.</p> \\[ {\\tau}_1 = rF_1 = yF_1 = 2mw^2 \\] <p>We have the same thing occuring with \\(p_2\\) as well. While the force has a negative sign, so does the torque radius (\\(r=-y=-1\\)) so we end up with the same torque. The total torque is the sum of the torques.</p> \\[ \\tau = {\\tau}_1 + {\\tau}_2 = 4mw^2 \\] <p>The torque acts in a clockwise direction (if we were to use a vector, it would point inwards). If we think about it, it makes sense. The torque tries to level the two points to be on the same rotational plane.</p> <p>This should give us some explanation to what the induced torque might be due to. Let's compare with the actual equations and see if they would produce the same.</p> <p>Following is the calculation of the moment of inertia tensor.</p> \\[ I_{xx} = \\sum_i{m_i (y_i^2 + z_i^2)} = m (1^2 + 0^2) + m ((-1)^2 + 0^2) = 2m \\] \\[ I_{yy} = \\sum_i{m_i (x_i^2 + z_i^2)} = m (2^2 + 0^2) + m ((-2)^2 + 0^2) = 8m \\] \\[ I_{zz} = \\sum_i{m_i (x_i^2 + y_i^2)} = m (2^2 + 1^2) + m ((-2)^2 + (-1)^2) = 10m \\] \\[ I_{xy} = I_{yx} = - \\sum_i{m_i x_i y_i} = - m(2)(1) -m(-2)(-1) = - 4m \\] \\[ I_{xz} = I_{zx} = - \\sum_i{m_i x_i z_i} = - m(2)(0) - m(-2)(0) = 0 \\] \\[ I_{yz} = I_{zy} = - \\sum_i{m_i y_i z_i} = - m(1)(0) - m(-1)(0) = 0 \\] <p>Which leads to the following tensor matrix.</p> \\[ I = \\begin{bmatrix} 2m &amp; -4m &amp; 0 \\\\ -4m &amp; 8m &amp; 0 \\\\ 0 &amp; 0 &amp; 10m \\\\ \\end{bmatrix} = 2m \\begin{bmatrix} 1 &amp; -2 &amp; 0 \\\\ -2 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 5 \\\\ \\end{bmatrix} \\] <p>Next we can use it to calculate the torque.</p> \\[ \\vec{\\tau} = \\vec{\\omega} \\times I \\vec{\\omega} = 2m \\begin{bmatrix} 0 \\\\ \\omega \\\\ 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; -2 &amp; 0 \\\\ -2 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 5 \\\\ \\end{bmatrix} \\begin{bmatrix} 0 \\\\ \\omega \\\\ 0 \\\\ \\end{bmatrix} \\] \\[ \\vec{\\tau} = 2m \\begin{bmatrix} 0 \\\\ \\omega \\\\ 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} -2 \\omega \\\\ 4 \\omega \\\\ 0 \\\\ \\end{bmatrix} = 4m \\begin{bmatrix} 0 \\\\ \\omega \\\\ 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} -1 \\omega \\\\ 2 \\omega \\\\ 0 \\\\ \\end{bmatrix} \\] <p>Just the cross product is calculated as follows.</p> \\[ \\begin{bmatrix} 0 \\\\ \\omega \\\\ 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} -1 \\omega \\\\ 2 \\omega \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\omega (0) - 0(2\\omega) \\\\ 0 (-1\\omega) - 0(0) \\\\ 0(2\\omega) - \\omega(-1\\omega) \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ {\\omega}^2 \\\\ \\end{bmatrix} = \\] <p>All of this produces the following result.</p> \\[ \\vec{\\tau} = 4m \\begin{bmatrix} 0 \\\\ 0 \\\\ {\\omega}^2 \\\\ \\end{bmatrix} \\] <p>This is a vector pointing inward that has a magnitude of \\(4m{\\omega}^2\\), just like we derived using the more basic math. What this means is that the centrifugal force must be the reason for the induced torque.</p> <p>NOTE: As previously stated, this is my personal reasoning for this and the math above seems to support it. Either way, there isn't much easy to read material out there on the matter, so this will have to do. End of the day, one should choose to use the official equations and should be fine. This is just an attempt to give some intuition and reasoning to those equations.</p>"},{"location":"development/physics/theory/moment-of-intertia/#acceleration-torque","title":"Acceleration torque","text":"<p>If an object has an angular acceleration, then clearly it can apply torque to whatever is trying to resist it. According to the main equation above, we should be able to calculate that torque using the first part.</p> \\[ \\vec{\\tau} = I\\vec{\\alpha} \\] <p>Let's have a look at our example setup again.</p> <p></p> <p>Before using the moment of inertia matrix to try and calculate that torque, let's try and figure it out using more basic physics and math.</p> <p>If we were to examine point \\(p_1\\), we can reason that it must have a tangential acceleration, if the whole object has an angular acceleration. The tangential acceleration of the point can be calculated as follows.</p> \\[ \\vec{a_t} = \\vec{\\alpha} \\times \\vec{r} \\] <p>Looking at the diagrams and the vectors, we know that that acceleration points inward, so we can use the more basic equations to calculate the magnitude.</p> \\[ a_t = \\alpha x = 2 \\alpha \\] <p>The force of that particle is then equal to the following.</p> \\[ F_1 = 2 m \\alpha \\] <p>Now that we have the particle's force, let's see how does that force affect the object across its three main axes.</p> <p>Since the force points inwards, it is parallel to the \\(Z\\) axis, hence it does not apply any torque over that axis. Hence we have \\({\\tau}_z = 0\\).</p> <p>It does apply a torque over the \\(Y\\) axis and the torque vector is of length \\(x = 2\\). This results in a torque \\({\\tau}_y = 2 m \\alpha 2 = 4 m \\alpha\\).</p> <p>Similarly, it applies a torque over the \\(X\\) axis and the torque vector is of length \\(y = 1\\). This results in a torque \\({\\tau}_x = - 2 m \\alpha 1 = - 2 m \\alpha\\). The negative sign is since the torque vector points to the left in this case.</p> <p>Combined, and multiplied by two, since particle \\(p_2\\) produces the same torques, we end up with the following torque vector.</p> \\[ \\vec{\\tau} = 4 m \\begin{bmatrix} - \\alpha \\\\ 2 \\alpha \\\\ 0 \\\\ \\end{bmatrix} \\] <p>Another example how the torque is not parallel to the angular acceleration.</p> <p>Now, let's use the official method of calculating it and see if we get the same result. We can reuse the tensor matrix from above, since the reference frame has not changed.</p> \\[ \\vec{\\tau} = I\\vec{\\alpha} = 2m \\begin{bmatrix} 1 &amp; -2 &amp; 0 \\\\ -2 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 5 \\\\ \\end{bmatrix} \\begin{bmatrix} 0 \\\\ \\alpha \\\\ 0 \\\\ \\end{bmatrix} = 2m \\begin{bmatrix} -2 \\alpha \\\\ 4 \\alpha \\\\ 0 \\\\ \\end{bmatrix} \\] \\[ \\vec{\\tau} = I\\vec{\\alpha} = 4m \\begin{bmatrix} - \\alpha \\\\ 2 \\alpha \\\\ 0 \\\\ \\end{bmatrix} \\] <p>Once again, we got the same result as with the manual, per-particle, approach. Hopefully, this should give an understanding as to why torque and angular acceleration need not point in the same direction.</p> <p>NOTE: And once again, take all of this with a grain of salt.</p>"},{"location":"development/physics/theory/principles/","title":"Principles","text":"<p>Following are some physics principles that are useful to keep in mind.</p>"},{"location":"development/physics/theory/principles/#tangental-velocity","title":"Tangental velocity","text":"<p>The velocity that a point \\(p\\) on an object experiences is equal to the sum of the velocity of the object and the angular velocity times the radius.</p> \\[ v_t = v + \\omega r \\]"},{"location":"development/physics/theory/principles/#tangental-acceleration","title":"Tangental Acceleration","text":"<p>From the tangental velocity, we can derive the tangental acceleration of an offset point to be as follows:</p> \\[ a_t = a + \\alpha r \\]"},{"location":"development/physics/theory/principles/#offset-torque","title":"Offset torque","text":"<p>If a torque is applied to an object at a point away from the center of mass, the behavior is the same as through the torque was applied at the center of mass.</p> <p>This is probably not so unknown nowadays, as drones demonstrate this principle very well - this is the mechanism through which they rotate about their vertical axis (yaw), even though the propellers are at an offset and are parallel to the horizontal plane.</p>"},{"location":"development/physics/theory/principles/#offset-force","title":"Offset force","text":"<p>If a force is applied to an object at a point away from the center of mass, both a force at the center of mass and a torque are applied to the object. What is interesting here is that the magnitute of the force is the same as would be if the force were applied at the center of mass.</p> <p>That is, given an object with a center of mass \\(\\vec{p_{cm}}\\) and a force \\(\\vec{F}\\) that is applied at point \\(\\vec{p}\\), the resulting force and torque arise.</p> \\[ \\vec{F_{cm}} = \\vec{F} \\] \\[ \\vec{\\tau_{cm}} = (\\vec{p} - \\vec{p_{cm}}) \\times \\vec{F} \\] <p>NOTE: Wrapping my head around the idea that a force applied at an offset affects the center of mass of the object in the same way as if it were applied at the center of mass was hard. If that were true, it felt that in the case where the force were applied at the center of mass there was a loss of energy since there was no rotational energy gain. I guess that one has to consider the motion of the object. An offset force will cause the object to spin faster and faster, leading to the motion being circular-like in shape and the object not gaining much potential energy. This is my personal way of thinking about this. Take this with a block of salt.</p>"},{"location":"development/physics/theory/terminology/","title":"Terminology","text":"Symbol Description \\(m\\) The mass of an object. Larger mass means that the object is harder to translate. \\(a\\) The acceleration of an object. Indicates the rate at which the velocity of an object changes. \\(v\\) The velocity of an object. Indicates the rate at which the object's position changes. \\(F\\) The force acting on an object. \\(p\\) The momentum of an object. Can be thought of as the impact potential of the object. \\(I\\) The moment of inertia of an object. Larger moment of inertia means that the object is harder to rotate. It also describes the rotational behavior of an object. \\(\\alpha\\) The angular acceleration of an object. Indicates the rate at which the angular velocity of an object changes. \\(\\omega\\) The angular velocity of an object. Indicates the rate at which the object's rotation changes. \\(\\tau\\) The torque acting on an object. \\(L\\) The angular momentum of an object. Can be thought of as the rotational impact potential of the object. \\(\\textit{e}\\) The coefficient of restitution of two objects. It describes the bounciness that an object experiences when colliding with another object, where the value differs depending on the characteristics of the two objects. \\(\\mu\\) The coefficient of friction of two objects. It describes how hard it is for two objects to slide when in contact, where the value differs depending on the characteristics of the two objects. It also differs depending on whether the two objects are initially at relative rest or are already sliding across each other. \\(\\rho\\) The density of a fluid or object. Determines how much mass there is per unit of volume. For a fluid it also determines how hard it is for an object to go through the fluid. \\(C_d\\) The drag coefficient of an object. It is determined by the shape of an object and is specific to a given orientation of the object. It describes how much an object's shape opposes the object's motion through a fluid or gas. \\(C_L\\) The lift coefficient of an object. The value depends on the object's shape, material, and the angle at which the fluid or gas hits the object."},{"location":"manual/application/","title":"Application","text":"<p>Under Development</p>"},{"location":"manual/game/","title":"Game","text":"<p>Under Development</p>"},{"location":"manual/graphics/shader/","title":"Shader","text":"<p>The Lacking game engine uses a custom shading language called LSL. This language is then transpiled to the respective GPU API shader language (e.g. GLSL, WGSL). The syntax of the language is very similar to the Go syntax, though there are some notable differences. Using Go-like syntax allows one to write in a consistent way game code and shader code. Furthemore, the Go syntax is designed to be easily and unambiguously parsable.</p>"},{"location":"manual/graphics/shader/#comments","title":"Comments","text":"<p>Comments can be added with <code>//</code> anywhere in the file, where the remainder of the line is considered a comment and is ignored.</p> <pre><code>// An example comment.\n</code></pre>"},{"location":"manual/graphics/shader/#operators","title":"Operators","text":"<p>There are a number of operators supported by the LSL language.</p>"},{"location":"manual/graphics/shader/#assignment-operators","title":"Assignment Operators","text":"<p>Following is a list of assignment operators that can be used to assign a value to a variable.</p> Operator Description <code>=</code> Assigns the value to the variable. Both sides need to have the same type. <code>:=</code> Defines a new variable and initializes it with the contents and type of the value. <code>+=</code> Adds the value to the variable. <code>-=</code> Subtracts the value from the variable. <code>*=</code> Multiplies the variable by the value. <code>/=</code> Divides the variable by the value. <code>%=</code> Assigns the modulo of the variable and the value. <code>&lt;&lt;=</code> Shifts the variable to the left by the value number of bits. <code>&gt;&gt;=</code> Shifts the variable to the right by the value number of bits. <code>&amp;=</code> Assigns the bitwise AND operation on the variable and the value to the variable. <code>\\|=</code> Assigns the bitwise OR operation on the variable and the value to the variable. <code>^=</code> Assigns the bitwise XOR operation on the variable and the value to the variable."},{"location":"manual/graphics/shader/#unary-operators","title":"Unary Operators","text":"<p>The following unary operators can be used inside expressions to transform a single sub-expression.</p> Operator Description <code>!</code> Inverts the value of the expression. It needs to be a boolean expression or a boolean vector expression. <code>-</code> Negates the value of the expression. It needs to be a numeric expression or a numeric vector expression. <code>+</code> A no-op change to the value of the expression. it needs to be a numeric expression vector expression. <code>^</code> Performs a bitwise NOT operation on the value of the expression. It needs to be a numeric expression or a numeric vector expression."},{"location":"manual/graphics/shader/#binary-operators","title":"Binary Operators","text":"<p>The following binary operators can be used inside expressions to combine two sub-expressions.</p> Operator Description <code>+</code> Returns the sum of the two expressions. Both sides need to be numeric expressions of the same type. <code>-</code> Returns the difference between the two expressions. Both sides need to be numeric expressions of the same type. <code>*</code> Returns the multiplication of the two expressions. Both sides need to be numeric expressions of the same type. <code>/</code> Returns the division of the two expressions. Both sides need to be numeric expressions of the same type. <code>%</code> Returns the modulo of the two expressions. Both sides need to be integer expressions of the same type. <code>&lt;&lt;</code> Returns the bitwise left-shift of the left expression by the right expression. Both sides need to be integer expressions. <code>&gt;&gt;</code> Returns the bitwise right-shift of the left expression by the right expression. Both sides need to be integer expressions. <code>==</code> Returns a boolean value indicating whether the two expressions are equal. Both sides need to be expressions of the same type and comparable. <code>!=</code> Returns a boolean value indicating whether the two expressions are different. Both sides need to be expressions of the same type and comparable. <code>&lt;</code> Returns a boolean value indicating whether the first expression is smaller than the second expression. Both sides need to be expressions of the same type and be ordered. <code>&gt;</code> Returns a boolean value indicating whether the second expression is smaller than the first expression. Both sides need to be expressions of the same type and be ordered. <code>&lt;=</code> Returns a boolean value indicating whether the first expression is smaller than or equal to the second expression. Both sides need to be expressions of the same type and be ordered. <code>&gt;=</code> Returns a boolean value indicating whether the second expression is smaller than or equal to the first expression. Both sides need to be expressions of the same type and be ordered. <code>&amp;</code> Returns the result of a bitwise AND operation on the two expressions. Both sides need to be integer expressions of the same type. <code>\\|</code> Returns the result of a bitwise OR operation on the two expressions. Both sides need to be integer expressions of the same type. <code>^</code> Returns the result of a bitwise XOR operation on the two expressions. Both sides need to be integer expressions of the same type. <code>&amp;&amp;</code> Returns the result of a logical AND operation on the two expressions. Both sides need to be boolean expressions of the same type. <code>\\|\\|</code> Returns the result of a logical OR operation on the two expressions. Both sides need to be boolean expressions of the same type."},{"location":"manual/graphics/shader/#types","title":"Types","text":"<p>The following table lists the supported built-in types.</p> Name Description <code>bool</code> Boolean type <code>int</code> 32 bit signed integer type <code>uint</code> 32 bit unsigned integer type <code>float</code> 32 bit floating point type <code>vec2</code> 2D vector type with two 32 bit floating point components <code>vec3</code> 3D vector type with three 32 bit floating point components <code>vec4</code> 4D vector type with four 32 bit floating point components <code>bvec2</code> 2D vector type with two boolean components <code>bvec3</code> 3D vector type with three boolean components <code>bvec4</code> 4D vector type with four boolean components <code>ivec2</code> 2D vector type with two 32 bit signed integer components <code>ivec3</code> 3D vector type with three 32 bit signed integer components <code>ivec4</code> 4D vector type with four 32 bit signed integer components <code>uvec2</code> 2D vector type with two 32 bit unsigned integer components <code>uvec3</code> 3D vector type with three 32 bit unsigned integer components <code>uvec4</code> 4D vector type with four 32 bit unsigned integer components <code>mat2</code> 2x2 matrix type with four 32 bit floating point components <code>mat3</code> 3x3 matrix type with nine 32 bit floating point components <code>mat4</code> 4x4 matrix type with sixteen 32 bit floating point components <code>sampler2D</code> sampler to a 2D texture <code>samplerCube</code> sampler to a Cube texture"},{"location":"manual/graphics/shader/#functions","title":"Functions","text":"<p>The following table lists built-in functions.</p> Name Variants Description <code>sin(float)</code> <code>sin(vec2)</code>, <code>sin(vec3)</code>, <code>sin(vec4)</code> Returns the sine of a value <code>cos(float)</code> <code>cos(vec2)</code>, <code>cos(vec3)</code>, <code>cos(vec4)</code> Returns the cosine of a value"},{"location":"manual/rendering/","title":"Rendering","text":"<p>Under Development</p>"},{"location":"manual/user-interface/","title":"User interface","text":"<p>Under Development</p>"}]}